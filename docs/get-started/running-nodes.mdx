---
title: 'Running Etherlink Nodes'
---

import Figure from '@site/src/components/Figure';

Anyone can run an Etherlink node to join the network, but operating an Etherlink node requires some familiarity with the Tezos ecosystem, Smart Rollups, and the Octez suite.

## Transaction life cycle

To run an Etherlink node, you must understand how transactions flow through Etherlink.

In its life cycle, an Etherlink transaction goes through three distinct types of nodes, each responsible for different aspects of Etherlink's features.
These three nodes are being developed as part of the [Octez software suite](https://tezos.gitlab.io/introduction/tezos.html):

- Etherlink nodes (`octez-evm-node`): The Etherlink nodes themselves maintain a local copy of the Etherlink context, apply new blocks as they are created, and expose a [JSON RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/) compliant endpoint to clients.
- Smart Rollup nodes (`octez-smart-rollup-node`): Etherlink nodes delegate interactions with Tezos layer 1 nodes through these Smart Rollup nodes.
- Tezos layer 1 nodes, also referred to as Octez nodes (`octez-node`): The Smart Rollup nodes listen to Tezos layer 1 nodes and react to what happens on the Tezos network.

The overall lifecycle of a typical operation is as follows:

1. A user submits a transaction to an Etherlink node.
2. The Etherlink node forwards the transaction to Etherlink's sequencer, which includes it in a new block as soon as possible (less than 500ms after receiving it in a nominal scenario).
3. The sequencer forwards the new block to the Smart Rollup node it is connected to.
4. The sequencer also shares the new block available with other Etherlink nodes, which continue to share it in a peer-to-peer manner.
4. The Smart Rollup nodes tracking the state of Etherlink fetch this new Etherlink block and validate it.
5. Validation from the Smart Rollup nodes allow the Etherlink nodes to assert that block has been faithfully posted by the sequencer.
6. Eventually, the Smart Rollup nodes assuming the role of "operators" commit the state of Etherlink to the Tezos network via the layer 1 nodes.

This diagram summarizes the interaction between the nodes:

<Figure src="/img/big-picture-nodes.png" alt="" />

## Running Etherlink nodes

Etherlink nodes require access to the RPCs of a running Smart Rollup node.
Therefore, to run an Etherlink node, you must also run a Smart Rollup node.
You can set up your own layer 1 node or use a public node.

The code for the three nodes is part of the [Octez suite](https://tezos.gitlab.io/).

- You can use a public layer 1 node or set up your own as described in [Installing Octez](https://tezos.gitlab.io/introduction/howtoget.html) in the Octez documentation.
- You can set up a Smart Rollup node (`octez-smart-rollup-node`) with a snapshot of the Etherlink state or from Etherlink genesis.
Setting up the Smart Rollup node from Etherlink genesis requires a recent build of the Octez suite.
- Octez does not yet provide a binary build of the Etherlink node, so you must build it from the source code.

### Running a Smart Rollup node for Etherlink

The Smart Rollup node runs the _kernel_, which is a Rust program compiled in WASM implementing the semantics of Etherlink blocks and transactions.
It is used by Etherlink nodes and Smart Rollup nodes to validate the blocks created by Etherlink's sequencer.
The Smart Rollup node verifies the integrity of the kernel based on a hash posted onchain during the origination of Etherlink.

To start, the node uses the _installer kernel_, which is a compressed version of the kernel that provides only enough information to install the original kernel.
The data for the original kernel is stored in separate files called _preimages_.
For more information about installer kernels and preimages, see the tutorial [Deploy a Smart Rollup](https://docs.tezos.com/tutorials/smart-rollup) on docs.tezos.com.

The Etherlink team maintains a file server with the preimages on a so-called "preimages endpoint".
These instructions cover how to start the Smart Rollup node using these preimages.
To build them yourself, see [Building the Etherlink kernel](#building-the-etherlink-kernel).

For simplicity, these steps show how to run the node in observer mode.

1. Get a built version of the Smart Rollup node binary, named `octez-smart-rollup-node`, in one of these ways:

   - To set up a Smart Rollup node from Etherlink genesis, it's best to use recent Octez source code.
   One commit that is known to work well is [`c5ed8f9`](https://gitlab.com/tezos/tezos/-/commit/c5ed8f9d5737cec03b29e5a7c3bf2169cc239ea8) from the `master` branch of the [Octez repository](https://gitlab.com/tezos/tezos).
   For more information about building Octez binaries, see the Octez documentation: https://tezos.gitlab.io/index.html

   - You can also use Octez binary builds.
   Builds for Linux systems are available for the [x86_64](https://gitlab.com/tezos/tezos/-/jobs/6849203975/artifacts/browse/octez-binaries/x86_64/) architecture.

1. Initialize the local context of the node, which is where it stores local data:

   1. Set the environment variable `sr_observer_data_dir` to the directory where the node should store its local data.
   1. Initialize the local context by running this command:

      ```bash
      octez-smart-rollup-node init observer config for sr1Ghq66tYK9y3r8CC1Tf8i8m5nxh8nTvZEf  \
        with operators --data-dir $sr_observer_data_dir
      ```

      This command generates a minimal configuration file (`config.json`) in the local data folder:

      ```json
      { "smart-rollup-address": "sr1Ghq66tYK9y3r8CC1Tf8i8m5nxh8nTvZEf",
        "smart-rollup-node-operator": {}, "fee-parameters": {},
        "mode": "observer" }
      ```

1. Activate the `unsafe-pvm-patches` setting, which is required for Etherlink, and add the location of the preimages by adding these settings to the `config.json` file, as in this example:

   ```json
   { "smart-rollup-address": "sr1Ghq66tYK9y3r8CC1Tf8i8m5nxh8nTvZEf",
     "smart-rollup-node-operator": {}, "fee-parameters": {},
     "unsafe-pvm-patches": [
       { "increase_max_nb_tick": "50_000_000_000_000" }
     ],
     "pre-images-endpoint": "https://snapshots.eu.tzinit.org/etherlink-mainnet/wasm_2_0_0",
     "mode": "observer" }
   ```

   Similar to the Rust keyword, `unsafe` here means to be used with a good understanding of the feature.
   Etherlink uses this setting with care and using it is safe in this context.

1. Start the Smart Rollup node in observer mode by running this command and using the RPC endpoint of a layer 1 node that is running in archive mode:

   ```bash
   octez-smart-rollup-node --endpoint https://rpc.tzkt.io/mainnet run \
     --data-dir $sr_observer_data_dir \
     --apply-unsafe-patches
   ```

   As in this example, you can use a public layer 1 RPC node for testing purposes.
   For production use, you must use a layer 1 node that is running in archive mode and provides access to its RPC endpoints.

   The `--apply-unsafe-patches` setting is required only the first time that you start the node.
   After that you can omit it.
   After the first run, you can also remove the `unsafe-pvm-patches` field from the configuration file.

   After the Smart Rollup node has caught up with the current state via the archive node, you can safely connect it to a rolling layer 1 node.

1. Verify that the Smart Rollup node is running by querying it.
For example, this query gets the latest block:

   ```bash
   curl -s http://localhost:8932/global/block/head
   ```

### Running an Etherlink node

To run an Etherlink node in observer mode from the Etherlink genesis block, you need:

- Access to a Smart Rollup node tracking the state of Etherlink, which you created in the previous section
- The Etherlink installer kernel (`installer.hex` file), which you can build yourself as described in [Building the Etherlink kernel](#building-the-etherlink-kernel) or download here: [installer.hex](/files/installer.hex)

Follow these steps to run the Etherlink node:

1. Set the `sr_node_observer_rpc` environment variable to the URL to the Smart Rollup node you set up in the previous section.
1. Set the `evm_observer_dir` environment variable to the directory where the node should store its local data.
1. Initialize the node by running this command:

   ```bash
   octez-evm-node init config --devmode \
     --data-dir $evm_observer_dir --rollup-node-endpoint $sr_node_observer_rpc \
     --preimages-endpoint https://snapshots.eu.tzinit.org/etherlink-mainnet/wasm_2_0_0 \
     --evm-node-endpoint https://node.mainnet.etherlink.com \
     --force
   ```

   This command uses premade preimages to set up the kernel based on the installer kernel that you built.
   It's safe to use these preimages, but if you don't trust them, you can move the contents of the `wasm_2_0_0/` directory that was created when you built the installer kernel to the local data directory.
   However, in this case, the kernel is not updated automatically, so you must manually update this directory with the preimages of every kernel voted by the community and deployed on Etherlink after that.

1. Run this command to start the node with the Etherlink installer kernel:

   ```bash
   octez-evm-node run observer --data-dir $evm_observer_dir --initial-kernel installer.hex
   ```

By default, the Etherlink node exposes its JSON RPC API endpoint to `localhost:8545`.
You can test that everything works as expected by running RPC requests manually or by setting your wallet to use your local node.

## Appendix

### Building the Etherlink kernel

It's not necessary to build Etherlink's kernel.
You can set the `pre-images-endpoint` field in the Smart Rollup node's configuration file as described in [Running a Smart Rollup node for Etherlink](#running-a-smart-rollup-node-for-etherlink).
Then you can download the installer kernel here: [installer.hex](/files/installer.hex).

However, if you want to build the kernel yourself, you can use these instructions.

This build process creates the installer kernel, which is a compressed version of the kernel that provides only enough information to install the original kernel.
The data for the original kernel is stored in separate files called preimages.
For more information about installer kernels and preimages, see the tutorial [Deploy a Smart Rollup](https://docs.tezos.com/tutorials/smart-rollup) on docs.tezos.com.

The Etherlink build process relies on a Docker image to ensure reproducible builds.

Follow these steps to build the installer kernel:

1. Clone the repository at https://gitlab.com/tezos/tezos.
1. Build the kernel by running this command from the root directory:

   ```bash
   ./etherlink/scripts/build-wasm.sh
   ```

   This command creates the file `etherlink/kernels-<CURRENT COMMIT>/evm_kernel.wasm`.

1. Run this command to install the installer kernel build dependencies:

   ```bash
   make -f kernels.mk build-deps kernel_sdk
   ```

1. Set the parameters for the installer kernel by running this command, which sets the chain ID, governance and bridge contracts, and other values:

   ```bash
   octez-evm-node make kernel installer config setup_file.yml --chain-id 42793 \
     --sequencer edpktufVZGs2JmEwHSFLdA7XHXotmnkD2Nwr75ACpxUr1iKUWzYFHJ      \
     --delayed-bridge KT1AZeXH8qUdLMfwN2g7iwiYYSZYG4RrwhCj                   \
     --ticketer KT1CeFqjJRJPNVvhvznQrWfHad2jCiDZ6Lyj                         \
     --sequencer-governance KT1NcZQ3y9Wv32BGiUfD2ZciSUz9cY1DBDGF             \
     --kernel-governance KT1H5pCmFuhAwRExzNNrPQFKpunJx1yEVa6J                \
     --kernel-security-governance KT1N5MHQW5fkqXkW9GPjRYfn5KwbuYrvsY1g       \
     --sequencer-pool-address 0xCF02B9Ca488f8F6F4E28e37AA1bDD16b3F1b2aD8     \
     --delayed-inbox-min-levels 1600 --remove-whitelist
   ```

1. Run this command to build the installer kernel:

   ```bash
   smart-rollup-installer get-reveal-installer \
     -u etherlink/kernels-b9f6c9138719220db83086f0548e49c5c4c8421f/evm_kernel.wasm \
     -o installer.hex \
     -P wasm_2_0_0 \
     -S setup_file.yml \
     -d
   ```

The output of the build process is the installer kernel itself, named `installer.hex`, and the preimages for the kernel, in the `wasm_2_0_0` directory.
